## 设计模式

主要参考了[JavaScript 设计模式核⼼原理与应⽤实践](https://juejin.cn/book/6844733790204461070/section/6844733790246404109)

什么是设计模式？

>  设计模式（Design pattern） 是解决软件开发某些特定问题而提出的一些解决方案也可以理解成解决问题的一些思路。是一套被反复使用、多人知晓的、经过分类的、代码设计经验总结。

通过设计模式可以帮助我们增强代码的可重用性、可扩充性、 可维护性、灵活性好。我们使用设计模式最终的目的是实现代码的 高内聚 和 低耦合。

什么是高内聚和低耦合？
举例一个现实生活中的例子，例如一个公司，一般都是各个部门各司其职，互不干涉。各个部门需要沟通时通过专门的负责人进行对接。在软件里面也是一样的 一个功能模块只是关注一个功能，一个模块最好只实现一个功能。这个是所谓的内聚，模块与模块之间、系统与系统之间的交互，是不可避免的， 但是我们要尽量减少由于交互引起的单个模块无法独立使用或者无法移植的情况发生， 尽可能多的单独提供接口用于对外操作， 这个就是所谓的低耦合

**设计模式的核心就是去观察你整个逻辑里的变与不变，然后将不变分离，达到使变化的部分灵活、不变的地方稳定的目的。**

### 工厂模式

这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。

在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。

在 JS 中其实就是借助构造函数实现。

举例：某个班级要做一个录入系统

录入一个人，就要写一次。

```js
let liMing = {
  name: "李明",
  age: 20,
  sex: "男",
};
```

如果多个录入，则可以创建一个类。

```js
class Student {
  constructor(name, age, sex) {
    this.name = name;
    this.age = age;
    this.sex = sex;
  }
}
let zhangSan = new Student("张三", 19, "男");
```

### 单例模式

> 单例模式的定义：保证一个类仅有一个实例，并且提供一个访问它的全局变量。实现的方法为前判断实例是否存在，如果存在直接返回，不存在则创建在返回，这就确保了一个类只有一个实例对象。

比如：Vuex、jQuery

使用场景：一个单一对象，比如：弹窗，无论点击多少次，弹窗只应被创建一次，实现起来也很简单，用一个变量缓存就行了。

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<style>
    .modal {
        width: 300px;
        height: 300px;
        position: fixed;
        top: 50%;
        left: 50%;
        margin-left: -150px;
        margin-top: -150px;
        border: solid #333 2px;
        text-align: center;
        border-radius: 5px;
    }
</style>

<body>
    <button id='btn'>按钮</button>
    <script>
        let getSingle = function (fn) {
            let reuslt = null;
            return function () {
                return reuslt || (reuslt = fn.apply(this, arguments))
            }
        }
        let createModal = function () {
            console.log('创建弹窗');
            let div = document.createElement('div');
            div.innerHTML = `
            <h2>登录弹窗</h2>
            <input type="text" placeholder="用户名">
            <br>
            <input type="password" placeholder="密码">
            <br>
            <button>登录</button>
            `;
            div.className = 'modal';
            document.body.appendChild(div)
            return div;
        }
        let modal = getSingle(createModal);
        btn.onclick = function () {
            console.log('点击按钮');
            let div = modal()
        }
    </script>
</body>

</html>
```

如上面这个弹框，只有在第一次点击按钮时才会创建弹框，之后都不会在创建，而是使用之前创建的弹框。

如此，便是实现了一个应用与单例模式的弹框。

### 订阅/发布模式（观察者）

pub/sub这个应该是前端用到最广的设计模式了。

这种模式中，并不是一个对象提哦啊用另一个对象的方法，而是一个对象订阅另一个对象的方法。

并在状态改变后获得通知，订阅者则为观察者，而被观察的对象成为发布者或者主题。

当发生了一个重要事件时候，发布者会通知（调用）所有订阅者并且可能经常已事件对象的形式传递消息。

比如：Vue 中的`$emit`和`$on`。

可以自己实现一个事件总线，模拟`$emit`和`$on`

```js
  class EventBus {
            constructor() {
                this.callbacks = {}
            }
            $on(name, fn) {
                (this.callbacks[name] || (this.callbacks[name] = [])).push(fn)
            }
            $emit(name, args) {
                let cbs = this.callbacks[name];
                if (cbs) {
                    cbs.forEach(c => {
                        c.call(this, args)
                    })
                }
            }
            $off(name) {
                this.callbacks[name] = null;
            }
        }
        let event = new EventBus()
        event.$on('event1', (arg) => {
            console.log('event1', arg)
        })

        event.$on('event2', (arg) => {
            console.log('event2', arg)
        })

        event.$emit('event1', 1)// event1 1
        event.$emit('event2', 2)// event2 2
```

