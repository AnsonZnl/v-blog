## 什么是设计模式

主要参考了[JavaScript 设计模式核⼼原理与应⽤实践](https://juejin.cn/book/6844733790204461070/section/6844733790246404109)

什么是设计模式？

> 设计模式（Design pattern） 是解决软件开发某些特定问题而提出的一些解决方案也可以理解成解决问题的一些思路。
>
> 它是一套被反复使用、多人知晓的、经过分类的、代码设计经验总结。
>
> 烹饪有菜谱，游戏有攻略，每个领域都存在一些能够让我们又好又快地达成目标的“套路”。在程序世界，编程的“套路”就是设计模式。

### 设计模式的原则

> 描述一个不断发生的重复的问题，以及该问题的解决方案的核心。
>
> 这样，你就能一次又一次的使用该方案而不必做重复劳动。

面向对象设计的五大原则：

- 单一功能原则
- 开放封闭原则
- 里氏替换原则
- 接口隔离原则
- 依赖翻转原则

JavaScript 中常用的是单一功能和开放封闭原则。

### 高内聚和低耦合

通过设计模式可以帮助我们增强代码的可重用性、可扩充性、 可维护性、灵活性好。我们使用设计模式最终的目的是实现代码的 高内聚 和 低耦合。

举例一个现实生活中的例子，例如一个公司，一般都是各个部门各司其职，互不干涉。各个部门需要沟通时通过专门的负责人进行对接。

在软件里面也是一样的 一个功能模块只是关注一个功能，一个模块最好只实现一个功能，这个是所谓的**内聚**。

模块与模块之间、系统与系统之间的交互，是不可避免的， 但是我们要尽量减少由于交互引起的单个模块无法独立使用或者无法移植的情况发生， 尽可能多的单独提供接口用于对外操作， 这个就是所谓的**低耦合**

### 封装变化

在实际开发过程中，不发生变化的代码基本是不存在的，所以我要将代码的变化最小化。

**设计模式的核心就是去观察你整个逻辑里的变与不变，然后将不变分离，达到使变化的部分灵活、不变的地方稳定的目的。**

## 设计模式的种类

常用的可以分为创建型、结构型、行为型三类，一共 23 种模式。

**创建型：**

- 单例模式
- 原型模式
- 构造器模式
- 工厂模式
- 抽象工厂模式

**结构型：**

- 桥接模式
- 外观模式
- 组合模式
- 装饰器模式
- 适配器模式
- 代理模式
- 享元模式

**行为型：**

- 迭代器模式
- 解释器模式
- 发布/订阅模式（观察者）
- 中介者模式
- 访问者模式
- 状态模式
- 备忘录模式
- 策略模式
- 模板方法模式
- 职责链模式
- 命令模式

只学习 JavaScript 中常用的几种模式，并结合案例加深印象。

## 创建型

### 工厂模式

> 这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。

在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。

在 JS 中其实就是借助构造函数实现。

举例：某个班级要做一个录入系统，录入一个人，就要写一次。

```js
let liMing = {
  name: "李明",
  age: 20,
  sex: "男",
};
```

如果多个录入，则可以创建一个类。

```js
class Student {
  constructor(name, age, sex) {
    this.name = name;
    this.age = age;
    this.sex = sex;
  }
}
let zhangSan = new Student("张三", 19, "男");
```

工厂模式是将创建对象的过程单独封装，使用使只需要无脑传参就行了，就像一个工厂一样，只要给够原料，就可以轻易的制造出成品。

小结：

- 构造函数和创建者分离，对 new 操作进行封装
- 符合开放封闭原则

### 单例模式

> 单例模式的定义：保证一个类仅有一个实例，并且提供一个访问它的全局变量。
>
> 实现的方法为前判断实例是否存在，如果存在直接返回，不存在则创建在返回，这就确保了一个类只有一个实例对象。

比如：Vuex、jQuery

使用场景：一个单一对象，比如：弹窗，无论点击多少次，弹窗只应被创建一次，实现起来也很简单，用一个变量缓存就行了。

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <style>
    .modal {
      width: 300px;
      height: 300px;
      position: fixed;
      top: 50%;
      left: 50%;
      margin-left: -150px;
      margin-top: -150px;
      border: solid #333 2px;
      text-align: center;
      border-radius: 5px;
    }
  </style>

  <body>
    <button id="show">显示</button>
    <button id="hide">隐藏</button>
    <script>
      let getSingle = function(fn) {
        let reuslt = null;
        return function() {
          return reuslt || (reuslt = fn.apply(this, arguments));
        };
      };
      let createModal = function() {
        console.log("创建弹窗");
        let div = document.createElement("div");
        div.innerHTML = `
            <h2>登录弹窗</h2>
            <input type="text" placeholder="用户名">
            <br>
            <input type="password" placeholder="密码">
            <br>
            <button>登录</button>
            `;
        div.className = "modal";
        document.body.appendChild(div);
        return div;
      };
      let modal = getSingle(createModal);
      show.onclick = function() {
        console.log("点击按钮");
        let div = modal();
        div.style.display = "block";
      };
      hide.onclick = function() {
        let div = modal();
        div.style.display = "none";
      };
    </script>
  </body>
</html>
```

如上面这个弹框，只有在第一次点击按钮时才会创建弹框，之后都不会在创建，而是使用之前创建的弹框。

如此，便是实现了一个应用与单例模式的弹框。

小结：

- 维持一个实例，如果已经创建，就直接返回
- 符合开放封闭原则

### 原型模式

> 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。

在 JavaScript 中，实现原型模式是在 ECMAscript5 中，提出的 Object.create 方法，使用现有的对象来提供创建的对象`__proto__`。

```js
var prototype = {
  name: "Jack",
  getName: function() {
    return this.name;
  },
};

var obj = Object.create(prototype, {
  job: {
    value: "IT",
  },
});

console.log(obj.getName()); // Jack
console.log(obj.job); // IT
console.log(obj.__proto__ === prototype); //true
```

## 结构型

### 装饰器模式

> 装饰器模式，又名装饰者模式。它的定义是“ 在不改变原对象的基础上，通过对其进行包装拓展，使原有对象可以满足用户的更复杂需求 ”。

**装饰器案例**    

有一个弹窗函数，点击按钮后会弹出一个弹框。

```js
function openModal(){
    let div = document.craeteElement('div');
    div.id = 'modal';
    div.innerHTML = '提示';
    div.style.backgroundColor = 'gray';
    document.body.appendChlid(div)
}
btn.onclick = ()=>{
    openModal()
}
```

但是忽然产品经理要改需求，要把提示文字由“提示”改为“警告”，背景颜色由gray改为red。

听到这个你是不是立马就想直接改动源函数：

```js{4,5}
function openModal(){
    let div = document.craeteElement('div');
    div.id = 'modal';
    div.innerHTML = '警告';
    div.style.backgroundColor = 'red';
    document.body.appendChlid(div)
}
```

但是如果是复杂的业务逻辑，或者这个代码时上任代码留下来的产物，在考虑到以后的需求变化，每次都这样修改确实很麻烦。

而且，直接修改已有的函数体，有违背了我们的“开放封闭原则”，往一个函数塞这么多的逻辑，也违背了“单一职责原则”，所以上面的方法并不是最佳的。

最省时省力的方式是不去关心它现有得了逻辑，只在此逻辑之上扩展新的功能即可，因此装饰器模式就此而生。

```js
// 新逻辑
function changeModal(){
    let div = document.getElemnetById('modal');
    div.innerHTML = '告警';
    div.style.backgroundColor = 'red';
}
btn.onclick = ()=>{
    openModal()
    changeModal()
}
```

这种通过函数添加新的功能、而又不修改旧逻辑，这就是装饰器的魅力。

**ES7 中的装饰器**

在最新的ES7中有装饰器的提案，但是还未定案，所以语法可能不是最终版，但是思想是一样的。

1. 装饰类的属性

```js
@tableColor
class Table {
  // ...
}
function tableColor(target) {
  target.color = 'red';
}
Table.color // true
```

为`Table`这个类，添加一个`tableColor`的装饰器，即可改变`Table`的`color`属性

2. 装饰类的方法

```js
class Person {
  @readonly
  name() { return `${this.first} ${this.last}` }
}
```

为`Person`类的`name`方法添加只读的装饰器，使得该方法不可被修改。

其实是借助`Object.defineProperty`的`wirteable`特性实现的。

3. 装饰函数

   因为JS中函数存在函数提升，直接使用装饰器并不可取，但是可以使用高级函数的方式实现。

   ```js
   function doSomething(name) {
     console.log('Hello, ' + name);
   }
   function loggingDecorator(wrapped) {
     return function() {
       console.log('fun-Starting');
       const result = wrapped.apply(this, arguments);
       console.log('fun-Finished');
       return result;
     }
   }
   const wrapped = loggingDecorator(doSomething);
   let name = "World";
   
   doSomething(name);// 装饰前
   // output:
   // Hello, World
   
   wrapped(name);// 装饰后
   // output:
   // fun-Starting
   // Hello, World
   // fun-Finished
   ```

   上面的装饰器，是给一个函数在执行开始和执行结束分别打印一个log。

**参考：**

- [ES6标准入门-decorators](https://es6.ruanyifeng.com/?search=%E8%A3%85%E9%A5%B0%E5%99%A8&x=0&y=0#docs/decorator)
- [推荐阅读-core-decorators](https://github.com/jayphelps/core-decorators)

### 适配器模式

> 适配器模式的作用是解决两个软件实体间的接口不兼容问题。使用适配器模式之后，原本由于接口不兼容而不能工作的两个软件实体可以一起工作。
>
> 简单来说，就是把一个类的接口变成客户端期待的另一种接口，**解决兼容问题**。

比如：axios

例子：一个渲染地图的方法，默认是调用当前地图对象的 show 方法进行渲染操作，当有多个地图，而每个地图的渲染方法都不一样时，为了方便使用者调用，就需要做适配了。

```js
let googleMap = {
  show: () => {
    console.log("开始渲染谷歌地图");
  },
};
let baiduMap = {
  display: () => {
    console.log("开始渲染百度地图");
  },
};
let baiduMapAdapter = {
  show: () => {
    return baiduMap.display();
  },
};
function renderMap(obj) {
  obj.show();
}
renderMap(googleMap); // 开始渲染谷歌地图
renderMap(baiduMapAdapter); // 开始渲染百度地图
```

这其中对“百度地图”做了适配的处理。

**总结：**

- 把变化留给自己，把统一留给用户。

## 行为型

### 订阅/发布模式（观察者）

> 发布/订阅模式又叫观察者模式，她定义对象间的一种一对多的依赖关系。当一个对象的状态发生改变时，所有依赖他的对象都将得到通知。在 JavaScrtipt 中，我们一般使用时间模型来替代传统的发布/订阅模式。

比如：Vue 中的双向绑定和事件机制。

**发布/订阅模式和观察者模式的区别**

- 发布者可以直接处接到订阅的操作，叫观察者模式

- 发布者不直接触及到订阅者，而是由统一的第三方完成通信操作，叫发布/订阅模式

  ![发布订阅模式和观察者模式.png](https://i.loli.net/2021/03/30/4TFJ3o1WhcPRzrq.png)

可以自己实现一个事件总线，模拟`$emit`和`$on`

```js
class EventBus {
  constructor() {
    this.callbacks = {};
  }
  $on(name, fn) {
    (this.callbacks[name] || (this.callbacks[name] = [])).push(fn);
  }
  $emit(name, args) {
    let cbs = this.callbacks[name];
    if (cbs) {
      cbs.forEach((c) => {
        c.call(this, args);
      });
    }
  }
  $off(name) {
    this.callbacks[name] = null;
  }
}
let event = new EventBus();
event.$on("event1", (arg) => {
  console.log("event1", arg);
});

event.$on("event2", (arg) => {
  console.log("event2", arg);
});

event.$emit("event1", 1); // event1 1
event.$emit("event2", 2); // event2 2
```

## 参考

- [JavaScript 设计模式核⼼原理与应⽤实践](https://juejin.cn/book/6844733790204461070)

- [JavaScript 中常用的设计模式](https://segmentfault.com/a/1190000017787537)
