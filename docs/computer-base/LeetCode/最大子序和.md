## 描述

给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

示例 1：

```输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
```

示例 2：

```
输入：nums = [1]
输出：1
```

示例 3：

```
输入：nums = [0]
输出：0
```

示例 4：

```
输入：nums = [-1]
输出：-1
```

示例 5：

```
输入：nums = [-100000]
输出：-100000
```

题目：[最大子序和](https://leetcode-cn.com/problems/maximum-subarray/)

## 解法

### 动态规划

这个想了半天也没写出来..

一开始看不懂，后来看了官方的题解，自己一步步 debug 才勉强看懂，但是还不是很完全理解。

```js
function maxArrSum(nums) {
  let sum = 0; // 维护一个当前最大数组的和
  let ans = nums[0]; // 维护一个当前的最大值
  let len = nums.length;
  for (let i = 0; i < len; i++) {
    let num = nums[i];
    if (sum >= 0) {
      sum = sum + num; // 如果小于或等于零 就+=
    } else {
      sum = num; // 大于零就赋值
    }
    ans = Math.max(sum, ans);
  }
  return ans;
}
let arr = [-2, 1, -3, 4, -1, 2, 1, -5, 4];
let result = maxArrSum(arr);
console.log(result); //6
```

## 思路

1. 动态规划的是首先对数组进行遍历，当前最大连续子序列和为 sum，结果为 ans
2. 如果 sum > 0，则说明 sum 对结果有增益效果，则 sum 保留并加上当前遍历数字
3. 如果 sum <= 0，则说明 sum 对结果无增益效果，需要舍弃，则 sum 直接更新为当前遍历数字
4. 每次比较 sum 和 ans 的大小，将最大值置为 ans，遍历结束返回结果

**复杂度分析**

- 时间复杂度：O(n)
- 空间复杂度：O(1)

## 总结

动态规划：是一种将复杂问题分解成更小问题来解决的优化技术
分而治之：将一个规模为 N 的问题分解为 K 个规模较小的子问题(K <= N)，这些子问题相互独立且与原问题性质相同，求出子问题的解，就可以求出原问题的解。

看不懂解法就 debug 一步一步的看怎么执行的，然后慢慢理解着看。

本文正在参与「掘金 2021 春招闯关活动」, 点击查看 [活动详情](https://juejin.cn/post/6933147477399109640)
