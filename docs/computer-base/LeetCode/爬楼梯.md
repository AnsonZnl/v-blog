## 描述

假设你正在爬楼梯。需要 n  阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

注意：给定 n 是一个正整数。

示例 1：

```
输入： 2
输出： 2
解释： 有两种方法可以爬到楼顶。
1.  1 阶 + 1 阶
2.  2 阶
```

示例 2：

```
输入： 3
输出： 3
解释： 有三种方法可以爬到楼顶。
1.  1 阶 + 1 阶 + 1 阶
2.  1 阶 + 2 阶
3.  2 阶 + 1 阶
```

题目：[爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)

## 解法

### 递归

通过题目描述，可以推算出规律如下：

- 1 节台阶：有 1 种方法
  - 1
- 2 节台阶：有 2 种方法
  - 1+1
  - 2
- 3 节台阶：有 3 种方法
  - 1+1+1
  - 1+2
  - 2+1
- 4 节台阶：有 5 种方法
  - 1+1+1+1
  - 1+2+1
  - 1+1+2
  - 2+1+1
  - 2+2
- 5 节台阶：有 8 种方法
  - 1+1+1+1+1
  - 1+1+1+2
  - ....

如此是可以找到规律的，出 1、2 节台阶外，之后的台阶是前两个台阶方法的总和，是一个典型的斐波那契数列。

因此可以使用递归的方式解答：

```js
function climbStairs(n) {
  if (n === 1 || n === 2 || n === 3) {
    return n;
  }
  return climbStairs(n - 1) + climbStairs(n - 2);
}
```

但是 LeetCode 提交如上代码会不通过，因为数大的时候运行时间过长，所以需要进一步优化。

```js
function climbStairs(n) {
  if (n === 1 || n === 2 || n === 3) {
    return n;
  }
  let memory = [0, 1, 2, 3];
  for (let i = 4; i <= n; i++) {
    memory[i] = memory[i - 1] + memory[i - 2];
  }
  return memory[n];
}
```

我们可以使用数组模拟递归的执行，将台阶数设为数据的索引，方法为数据，以 0-3 为基础，将 n 之前的方法全部推算出来，然后 for 出来即可，这种方法也称为**记忆递归法**。

### 动态规划

我们用 f(x) 表示爬到第 x 级台阶的方法数，考虑最后一步可能跨了一级台阶，也可能跨了两级台阶，所以我们可以列出如下式子：

```
f(x)=f(x−1)+f(x−2)
```

也就是说当我们求 x 级台阶的方法数的时候，其实只需要知道 x-1 和 x-2 的方法数就可以了，以此类推。

边界条件：从 0 级台阶到 0 级台阶只有一种方法。

因此，我们可以使用滚动数组实现这一次方法。

```js
var climbStairs = function(n) {
  let p = 0, // x-2 方法数
    q = 0, // x-1 的方法数
    r = 1; // 当前 n 方法数
  for (let i = 1; i <= n; ++i) {
    p = q;
    q = r;
    r = p + q;
  }
  return r;
};
```

![步骤示意图](https://assets.leetcode-cn.com/solution-static/70/70_fig1.gif)

## 总结

斐波那契数列的通用公式：f(x) = f(x-1) + f(x-2)

动态规划的思想：动态规划是把一个大问题拆解成一堆小问题的思想，

遇到问题不要慌，在纸上画画，然后一步一步的观察规律，总结规律。
