# 前端文件下载的正确打开方式

## a 标签

通过 `a` 标签的`download`属性来实现文件下载，这种方式是最简单的，也是我们比较常用的方式，先来看示例代码：
``` html
<a href="http://www.baidu.com" download="baidu.html">下载</a>
```
就上面的这个示例，我们点击下载，发现是跳转到了百度的首页，并没有真的下载文件。

因为`a`标签下载只能下载同源的文件，如果是跨域的文件，这里包括图片、音视频等媒体文件，都是预览，也无法下载。

上面的代码是直接通过书写`a`标签来实现文件下载，我们也可以通过`js`来实现，代码如下：

``` js
const a = document.createElement('a')
a.href = 'http://www.baidu.com'
a.download = 'baidu.html'
a.click()
```

效果和上面的一样，都是跳转到百度的首页，没有下载文件。

这里的重点是`a`标签的`download`属性，这个属性是HTML5新增的。

它的作用是指定下载的文件名，如果不指定，那么下载的文件名就会根据请求内容的`Content-Disposition`来确定，如果没有`Content-Disposition`，那么就会使用请求的URL的最后一部分作为文件名。

## window.open
上面使用a标签的案例也可以通过`window.open`来实现，效果是一样的，代码如下：
```js
window.open('http://www.baidu.com', '_blank')
```
这里的`_blank`是指定打开的方式，如果不指定，那么就会在当前页面打开，这里指定`_blank`，就是在新的页面打开。

同样`a`标签的`download`属性也是可以使用的，代码如下：
```js
window.open('http://www.baidu.com', '_blank', 'download=baidu.html')
```

当然这种方式也是有缺陷的，对比于`a`标签，这种方式不能下载.html、.htm、.xml、.xhtml等文件，因为这些文件会被当成`html`文件来处理，所以会直接在当前页面打开。

同样也不能下载跨域的文件，毕竟是`window.open`，不是`window.download`（`window.download`是假想）。

## location.href
这种方式和window.open(url)是一样的，代码如下：
```js
location.href = 'http://www.baidu.com'
```
这种方式拥有`window.open`的所有缺陷，所以不推荐使用，这里只当作了解，所以不做过多的讲解。

## location.?其他属性
这里的其他指代的都是能跳转页面的属性，比如`location.assign`、`location.replace`、`location.reload`等，这些属性都是可以实现文件下载的，代码如下：
``` js
location.assign('http://www.baidu.com')
location.replace('http://www.baidu.com')
location.reload('http://www.baidu.com')
```
这里的`location.reload`是有点特殊的，它的作用是重新加载当前页面，但是它也可以接受一个参数，这个参数就是要跳转的页面，所以也可以实现文件下载。

当然同`location.href`一样，这些方式的缺点都一样，同时还有属于每个属性自身的特性，这里只当拓展知识，不做过多的讲解。

## XMLHttpRequest

这种方式就是我们常说的`ajax`下载，包括`axios`、`fetch`等都是相同的，代码如下：
``` js
const xhr = new XMLHttpRequest()
xhr.open('GET', 'http://www.baidu.com')
xhr.send()

xhr.onload = function () {
  const blob = new Blob([xhr.response], { type: 'text/html' })
  const a = document.createElement('a')
  a.href = URL.createObjectURL(blob)
  a.download = 'baidu.html'
  a.click()
}

```
这里就不讲和`XMLHttpRequest`相关的知识了，只讲和文件下载相关的部分。

这里主要的逻辑是当我们的请求成功后，我们会拿到响应体的`response`，这个`response`就是我们要下载的内容，然后我们把它转换成`blob`对象，然后通过URL.`createObjectURL`来创建一个url，然后通过a标签的`download`属性来实现文件下载。

这里的知识点就有两个，一个是`blob`对象，一个是`URL.createObjectURL`。
