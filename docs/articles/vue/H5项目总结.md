移动端适配

- 响应式框架：bootstrap
- Rem布局：vant

请求库

- axios：http://www.axios-js.com/zh-cn/docs/

Vant 上传图片

```js
<template>
  <van-uploader :after-read="submitPic" />
</template>

<script>
  export default {
    data () {
     return {}
   },
    methods:{
      submitPic (file) {
      let params = new FormData();
      params.append("fileUpload", file.file);
      let config = {
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded'
        }
      }
      let url = `http://www.baidu.com`;
      this.axios.post(url, params, config).then(res => {
        console.log("msg", res);
      });
    },    
}
}
// https://www.cnblogs.com/liea/p/11933273.html
</script>
```

传参：

[详解vue 路由跳转四种方式 (带参数)](https://www.jb51.net/article/160401.htm)

鉴权

- [Vue 项目中的登录鉴权](https://www.cnblogs.com/superlizhao/p/10991300.html)

登录前和登录后的组件变动

- 通过vuex将登录状态共享

- 通过computer来控制

登录和退出登录的状态也是通过vuex来改变

- state 存放状态
- mutation 是改变state的唯一方式

通过axios创建的实例来统一的拦截处理

- 统一headers：axios.default.headers = {}

- 通过请求/响应的拦截：axios.interceptorts.request.use(..)   axios.interceptorts.request.use(..)

  

  

Axios坑

- 第一次登录是不需要token的，所有登录使用默认的axios服务
- 登录之后的每一次请求都要携带token，使用自己的axios 实例请求，并设置headers[token]
- 配置跨域，实例则不需要设置baseUrl

nav

- watch vuex 的 isLogin状态，如变动，则请求getUserInfo
-  请求数据并渲染





Vuex

- state中的值必须用sessionStroage/localStrogae做持久化，不然刷新页面会丢失数据



打包之后

将images放在css/里一份



相对文件路径使用proxy代理



Vue实时获取页面宽高:https://www.jianshu.com/p/2bcf0b4b6e72

```js

export default {
    name: 'page-index',
    data(){
        return{
            windowWidth: document.documentElement.clientWidth,  //实时屏幕宽度
            windowHeight: document.documentElement.clientHeight,   //实时屏幕高度
        }
    },    
    methods: {
    },
    // <!--在watch中监听实时宽高-->
    watch: {
      windowHeight (val) {
        let that = this;
        console.log("实时屏幕高度：",val, that.windowHeight );
      },
      windowWidth (val) {
        let that = this;
        console.log("实时屏幕宽度：",val, that.windowHeight );
      }
    },

    mounted() {
        var that = this;
        // <!--把window.onresize事件挂在到mounted函数上-->
        window.onresize = () => {
            return (() => {
              window.fullHeight = document.documentElement.clientHeight;
                window.fullWidth = document.documentElement.clientWidth;
              that.windowHeight = window.fullHeight;  // 高
              that.windowWidth = window.fullWidth; // 宽
            })()
          };
    },
}

```

