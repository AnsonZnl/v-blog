# 装饰器

因为最近对 [NestJS](https://nestjs.bootcss.com/) 比较感兴趣看到很多装饰器的写法，所有想要深入学习一下。

[装饰器](https://es6.ruanyifeng.com/#docs/decorator)是一个还处于草案中的特性，目前没有直接支持该语法的环境，但是可以通过 babel 之类的进行转换为旧语法来实现效果，所以在 TypeScript 中，可以放心的使用@Decorator。

## 简介

装饰器（Decorator）用来增强 JavaScript 类（Class）的功能，许多面向对象的语言都有这种语法，未来或许会将其引入了 ECMAScript 标准中。

装饰器是一种函数，可以写成`@+函数名`，主要可以装饰四种类型的值。

-   类
-   类的属性
-   类的方法
-   属性存取器（accessor）

下面的例子是装饰器放在类名和类方法名之前，大家可以感受一下写法。

```ts
@frozen
class Foo {
    @configurable(false)
    @enumerable(true)
    method() {}

    @throttle(500)
    expensiveMethod() {}
}
```

上面代码一共使用了四个装饰器，一个用在类本身（@frozen），另外三个用在类方法（@configurable()、@enumerable()、@throttle()）。它们不仅增加了代码的可读性，清晰地表达了意图，而且提供一种方便的手段，增加或修改类的功能。

## 装饰器 API 函数

## 类的装饰

```js
@testable
class MyTestableClass {
    // ...
}

function testable(target) {
    target.isTestable = true;
}

MyTestableClass.isTestable; // true
```

上面代码中，@testable 就是一个装饰器。它修改了 MyTestableClass 这个类的行为，为它加上了静态属性 isTestable。testable 函数的参数 target 是 MyTestableClass 类本身。

基本上，装饰器的行为就是下面这样。

```js
@decorator
class A {}

// 等同于

class A {}
A = decorator(A) || A;
```

也就是说，装饰器是一个对类进行处理的函数。装饰器函数的第一个参数，就是所要装饰的目标类。

```js
function testable(target) {
    // ...
}
```

上面代码中，testable 函数的参数 target，就是会被装饰的类。

如果觉得一个参数不够用，可以在装饰器外面再封装一层函数。

```js
function testable(isTestable) {
    return function (target) {
        target.isTestable = isTestable;
    };
}

@testable(true)
class MyTestableClass {}
MyTestableClass.isTestable; // true

@testable(false)
class MyClass {}
MyClass.isTestable; // false
```

上面代码中，装饰器 testable 可以接受参数，这就等于可以修改装饰器的行为。

注意，装饰器对类的行为的改变，是代码编译时发生的，而不是在运行时。这意味着，装饰器能在编译阶段运行代码。也就是说，**装饰器本质就是编译时执行的函数。**


## 装饰类的方法

方法装饰器会修改类的方法。
``` js
class C {
  @trace
  toString() {
    return 'C';
  }
}

// 相当于
C.prototype.toString = trace(C.prototype.toString);
```

上面示例中，@trace装饰toString()方法，就相当于修改了该方法。

方法装饰器使用 TypeScript 描述类型如下。
``` js
type ClassMethodDecorator = (value: Function, context: {
  kind: "method";
  name: string | symbol;
  access: { get(): unknown };
  static: boolean;
  private: boolean;
  addInitializer(initializer: () => void): void;
}) => Function | void;
```
方法装饰器的第一个参数value，就是所要装饰的方法。

方法装饰器可以返回一个新函数，取代原来的方法，也可以不返回值，表示依然使用原来的方法。如果返回其他类型的值，就会报错。下面是一个例子。
``` js
function replaceMethod() {
  return function () {
    return `How are you, ${this.name}?`;
  }
}

class Person {
  constructor(name) {
    this.name = name;
  }
  @replaceMethod
  hello() {
    return `Hi ${this.name}!`;
  }
}

const robin = new Person('Robin');

robin.hello(), //'How are you, Robin?'
```
## 装饰类的属性

## 应用于函数

装饰器只能用于类和类的方法，不能用于函数，因为存在函数提升(如果一定要装饰函数，可以使用高阶函数直接执行)。
``` js
function doSomething(name) {
  console.log('Hello, ' + name);
}

function loggingDecorator(wrapped) {
  return function() {
    console.log('Starting');
    const result = wrapped.apply(this, arguments);
    console.log('Finished');
    return result;
  }
}

const wrapped = loggingDecorator(doSomething);
```




## 参考

-   [ES6-装饰器](https://es6.ruanyifeng.com/#docs/decorator)
-   [Javascript 装饰器的妙用](https://juejin.cn/post/6844903635168526343)
-   [使用 TypeScript 装饰器装饰你的代码](https://juejin.cn/post/6844903876605280269)
