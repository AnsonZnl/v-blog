# 浏览器截图方案分析

"页面截屏"是前端经常遇到的需求，比如页面生成海报，弹窗图片分享等.以下是我整理三种截图方案。
1、html2canvas 
2、dom-to-image
3、webRTC
## html2canvas
[html2canvas](http://html2canvas.hertzen.com/) 用的比较广泛的前端截图方案，先将 DOM 一个个 转为 Canvas 然后导出图片（使用canvas自带的toDataUrl、toBobl）即可。使用起来应该是兼容性比较好的方案了，能解决大部分的需求，但是也有一写小问题，如：
1、图片跨域，开启
2、CSS属性错乱
3、遇到canvas元素导出后为透明色。

大部分问题还是可以通过配置和百度解决的
``` js
 const getDomImg = (eleId) => {
    html2canvas(document.getElementById(eleId), {
        //superMap整个页面的节点
        backgroundColor: null, //画出来的图片有白色的边框,不要可设置背景为透明色（null）
        allowTaint: true,
        useCORS: true, //支持图片跨域
        scale: 1, //设置放大的倍数
    })
        .then((canvas) => {
            //截图用img元素承装，显示在页面的上
            let img = new Image()
            img.src = canvas.toDataURL('image/jpg') // toDataURL :图片格式转成 base64
            // 直接下载
            let a = document.createElement('a')
            a.href = canvas.toDataURL('image/jpeg')
            a.download = 'test'
            a.click()
        })
        .catch((err) => {
            console.log('html2canvas err', err)
        })
}


```

## dom-to-image
使用svg，通过createObjectURL或encodeURIComponent处理svg得到图像资源，可以把svg绘制到canvas。
[dom-to-image-more](https://www.npmjs.com/package/dom-to-image-more) 是[dom-to-image](https://github.com/tsayen/dom-to-image)的升级版 将 HTMl 放到 SVG 里，然后创建一个以 SVG 作为源的 Image 元素

但是也有一些问题如： svg中不允许外部资源（js，css，img的url等），svg中不支持执行js，需要经过处理，也不能完全还原
``` js
const getDomImg = (eleId) => {
    domtoimage
        .toPng(document.getElementById(eleId))
        .then(function (dataUrl) {
            let a = document.createElement('a')
            a.href = dataUrl
            a.download = 'test'
            a.click()
        })
        .catch(function (error) {
            console.error('生成失败', error)
        })
}

```
## webRTC

使用浏览器原生 API——[webERT](https://developer.mozilla.org/zh-CN/docs/Web/API/WebRTC_API)中的[getDisplayMedia](https://developer.mozilla.org/zh-CN/docs/Web/API/MediaDevices/getDisplayMedia)可以将窗口中的资源以录屏方式从其中拿出一帧，但是需要用户授权和做一些窗口选择，相比于前两种方案做不到默认截图。但是优势也很明显，就是不会有什么样式错乱、图片跨域等问题。因为使用的浏览器原生方法，基本上用户看到是什么样子，截图出来就是什么样子，1: 1还原。
``` js
function getDomImg(videoId: string) {
    const videoElem: any = document.getElementById(videoId)

    const displayMediaOptions = {
        audio: false,
        video: { width: window.screen.width, height: window.screen.height }, // cursor: "always"
    }

    navigator.mediaDevices
        .getDisplayMedia(displayMediaOptions)
        .then((stream) => {
            videoElem.srcObject = stream
            setTimeout(() => {
                var canvas = document.createElement('canvas')
                canvas.width = videoElem.clientWidth
                canvas.height = videoElem.clientHeight
                canvas.getContext('2d')
                .drawImage(videoElem, 0, 0, window.screen.width, window.screen.height,0,0,canvas.width,   canvas.height)
                var dataURL = canvas.toDataURL('image/webp')
                let a = document.createElement('a')
                a.href = dataURL
                a.download = 'test'
                a.click()
                let tracks = videoElem.srcObject.getTracks()
                tracks.forEach((track) => track.stop())
                videoElem.srcObject = null
            }, 200)
        })
        .finally(() => {})
}

```


## 参考
- [史上最详细浏览器端网页截图方案解析](https://juejin.cn/post/6917133503297486861)
- [一款实用的前端截图工具](https://juejin.cn/post/6844903632958144520#comment)